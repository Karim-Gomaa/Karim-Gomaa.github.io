---
title: "$tealer "
classes: wide
header:
  teaser: /assets/images/malware-analysis/$tealer/path.jpg
ribbon: Black
description: "$tealer walkthrough (Dridex Based) ..."
categories:
  - Malware-Analysis
toc: true
---

- Challenge Link:

[Cyber Defender](https://cyberdefenders.org/blueteam-ctf-challenges/85#nav-questions)

---

## Scenario

Your enterprise network is experiencing a malware infection, and your SOC L1 colleague escalated the case for you to investigate. As an experienced L2/L3 SOC analyst, analyze the malware sample, figure out what it does and extract C2 server and other important IOCs.

---
## Basic Analysis

$tealer is a PE32 executable (DLL) (console) Intel 80386, for MS Windows

It kinda has no intersting strings except:
```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
Sleep
OutputDebugStringA
KERNEL32.dll
```
It is unpacked with four sections and two imported **API** as noticed from `PE-bear`.

![](/assets/images/malware-analysis/$tealer/sections.png)<br>
![](/assets/images/malware-analysis/$tealer/imports.png)

We knew that it is unpacked from `PEID` and there is more we can know, Using **KANAL** plugin we can know if there is any cryptography and where:
```
aPLib :: 0000AC81 :: 005FAC81
	The reference is above.
BASE64 table :: 0003A260 :: 0062A260
	The reference is above.
CRC32 [poly] :: 0003A310 :: 0062A310
	Referenced at 0061D659
	Referenced at 0061D6B6
	Referenced at 0061D836
	Referenced at 0061DAA8
CRC32 [poly] :: 0003A314 :: 0062A314
	The reference is above.
CRC32 [poly] :: 0003A318 :: 0062A318
	The reference is above.
CRC32 [poly] :: 0003A31C :: 0062A31C
	The reference is above.
```
So now I know that malware uses `CRC32(Cyclic Redundancy Check 32)` and `BASE64 table` 

here i tried to run the file but it seems to be using some evasion technique 

![](/assets/images/malware-analysis/$tealer/run.png)


Now it is IDA time.

---

## Advanced Analysis

I noteced before that it only imports KERNEL32.dll which doesn't make sense, so it must be hiding API calls.

First thing to take your eye is the strange function calls at EP

![](/assets/images/malware-analysis/$tealer/EP.png)

and the most intersting is the arguments passed for fun_2

![](/assets/images/malware-analysis/$tealer/API_HASH.png)

from decompiler noteced that function **sub_6015C0** takes the same arguments twice and it's return value will be called as a function, it's sounds like API-Hashing.
To be sure let's dive into the function and see what is happening.

![](/assets/images/malware-analysis/$tealer/resolve_1.png)

here, declare vars, assign some value to `V2` thenmake some comparasons and search for second argument.

![](/assets/images/malware-analysis/$tealer/resolve_3.png)

then at `lable 18` first argument is passed to **sub_607564** which in my assumption must be dll name so this function should get the dll name corresponding to given hash to use it to resolve the module name later.

in this function `-ResolveDllName-` again the hash is assigned to varible `v2` then some noisy comparasons happens, after that there is an access to **PEB** (ProcessEnvironmentBlock). 

![](/assets/images/malware-analysis/$tealer/nt.png)

from **PE** it access **Ldr**, as you seeida identified PEB & Ldr as structs but failed with Forward and Backward links so it must be reset.

![](/assets/images/malware-analysis/$tealer/structs.png)

now it gives a better view, so I now know it's tring to access **BaseDllName** which is struct as well 
```c
//0x8 bytes (sizeof)
struct _UNICODE_STRING
{
    USHORT Length;                                                          //0x0
    USHORT MaximumLength;                                                   //0x2
    WCHAR* Buffer;                                                          //0x4
}; 
```
here we notice that name is not accessed drictly but after 0x4 b as there are 2 struct members before it.
now malware access buffer -to get the name- and the leanth in the infinit loob `while(1)` ,then it will loop again on dll name and convert to lower case by subtracting 32 from each character.

![](/assets/images/malware-analysis/$tealer/to_lower.png)

aftre that it checks the hash dll with ginirated hash if equals break the infint loop, so basicly the function **sub_61D620** os the one responsible for hashing.

![](/assets/images/malware-analysis/$tealer/break.png)

Here we needa notice 2 things:
 - The returned value is XORed with `0x38BA5C7B` as second stage encrybtion.
 - The hashing algorithm is CRC32 as known from **KANAL** previouslly.

now after resolving dll name malware will return dll base address. If this case faced false condition, the malware will access next dll using Flink and repeat the loop.

![](/assets/images/malware-analysis/$tealer/final_resolve.png)

now back to our function `-ResolveDllName-` we find that it returns the value of function **sub_6067C8** which take two args, we can assume those are (Dll_Base,APIHash).
Need get depper in this function.

it started the comparasons then go to access export table.

![](/assets/images/malware-analysis/$tealer/headers.png)

To to do that it:
  - goes to `e_lfanew` in **_IMAGE_DOS_HEADER**
  - from  `e_lfanew` goes to **_IMAGE_NT_HEADERS**
  - from **NT** it moves `0x18` to access **_IMAGE_OPTIONAL_HEADER** 
  - from **optional** it moves`0x60` to acsess **_IMAGE_DATA_DIRECTORY** that make `0x78`
  - finally access **VirtualAddress** where our desired **EXPORT_DIRECTORY**

finall xor with the same key.

now, using hashdb with CRC32 algorithm and 0x38BA5C7B XOR key you can resolve any API and DLL as you want.

now after getting how the api resolved, we need to analyse the functionality.
let's start from the entry point with our frist call `sub_607980`.
Diving into this function find that: 
  this function simply resolve ntdll and import RtlAddVectoredExceptionHandler api which Registers a vectored exception handler.
That means our malware tryes to achiev **Vector Exception Handle** technique.

next go to **KERNEL32DLL** and import 
- CreateThread
- TerminateProcess
- FreeConsole
- VirtualFree
- ExitThread

using **CAPA** to give a queck hint on it's capablties found that:
### ATT&CK Techniques and MBC Behaviors

| ATT&CK Tactic      | ATT&CK Technique              | MBC Objective       | MBC Behavior                                      |
|--------------------|-------------------------------|---------------------|---------------------------------------------------|
| DEFENSE EVASION    | Obfuscated Files or Info     | CRYPTOGRAPHY        | Encrypt Data::RC4 [C0027.009]                     |
|                    | [T1027]                       |                     | Encryption Key::RC4 KSA [C0028.002]               |
|                    |                               |                     | Generate Pseudo-random Sequence::RC4 PRGA [C0021.004]|
| DISCOVERY          | Process Discovery [T1057]     | DATA                | Check String [C0019]                              |
|                    |                               |                     | Encoding::Base64 [C0026.001]                      |
| EXECUTION          | Shared Modules [T1129]        |                     | Encoding::XOR [C0026.002]                         |
|                    |                               |                     | Disable or Evade Security Tools::Heavens Gate [F0004.008] |
|                    |                               |                     | Obfuscated Files or Info::Encoding-Standard Algorithm [E1027.m02] |

### CAPABILITIES

- 64-bit execution via heavens gate (7 matches) [anti-analysis/anti-disasm]
- reference Base64 string [data-manipulation/encoding/base64]
- encode data using XOR (8 matches) [data-manipulation/encoding/xor]
- encrypt data using RC4 KSA [data-manipulation/encryption/rc4]
- encrypt data using RC4 PRGA [data-manipulation/encryption/rc4]
- print debug messages [host-interaction/log/debug/write-event]
- get process heap force flags [host-interaction/process]
- access PEB ldr_data [linking/runtime-linking]
- enumerate PE sections (3 matches) [load-code/pe]
- parse PE exports (4 matches) [load-code/pe]
- parse PE header (21 matches) [load-code/pe]


first, for RC4 we need a key, **sub_61E5D0** is one useing RC4 using Xref we find that the argument function takes alwayes data stored in `.rdata` where first 40 byte is the key.

now the entry point has ended but there maybe anthoer hidden call, so I used Xref one more time to check where is api_resolving function is called and get all api calls.
I found two functions remain without resolving **sub_623370** and **sub_623820**

after resolveing them found **WININET_DLL**:
- InternetCloseHandle
- InternetConnectW
- InternetQueryOptionW
- HttpQueryInfoW
- HttpSendRequestW

so there must be a connection with c2 server, to get all information about network based indicators found first that **InternetConnectW** is resolved in function **sub_623370**. This one especially accepts the `lpszServerName` parameter which points to host name or ip address.
So now I need to find where the **sub_623370** is called using Xref then search for arguments passed and get ip.

![](/assets/images/malware-analysis/$tealer/xref.png)

following these functions in reversed order till I found ip extraction:

![](/assets/images/malware-analysis/$tealer/parser.png)

that `do while` loop os where IPs are extracted from `.data` section.
going to `word_62B02B` in memory found:

![](/assets/images/malware-analysis/$tealer/ip.png)

As known, IPv4 is 4-byte so all we need now is to convert from int to ip.
uscing any converster you will get : 

![](/assets/images/malware-analysis/$tealer/1IP.png)

the same way get the port from next 2-bytes : 0x0BB1 => 443

The same way with the rest memory you will find four IPs.

| No |   IP Address   | Port Number |
|----|----------------|-------------|
| 1  | 192.46.210.220 |     443     |
| 2  | 143.244.140.214|     808     |
| 3  |   45.77.0.96   |    6891     |
| 4  |  185.56.219.47 |    8116     |


---

## tools

- PE-bear
- peid & KANAL plugin
- floss.exe
- IDAPRO7.7
- capa plugin
- hashdp plugin


---

## Resourses

- [Advanced Imports Obfuscation](https://amr-git-dot.github.io/malware%20analysis/Advanced_Imports_Obfuscation/#getmodulehandle-implementation-source-code)

- [VERGILIUS](https://www.vergiliusproject.com/)
- [Windows API Hashing in Malware](https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware)

---
#### Written by

## *Karim Gomaa*
